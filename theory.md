## Устные вопросы  

#### 1. Какой самый эффективный способ конкатенации строк?  
 
- Конкатенация - объединение нескольких строк в одну  
- strings.Builder - при вызове метода String() не происходит повторного выделения памяти и копирования данных
>func concat2builder(str1, str2 string) string {  
>var builder strings.Builder  
>builder.Grow(len(str1) + len(str2)) //выделение памяти под длину соедененных строк,чтобы не было нескольких реаллокаций буфера.  
>builder.WriteString(str1)  
>builder.WriteString(str2)  
>return builder.String()  
>}  


#### 2. Что такое интерфейсы, как они применяются в Go?
> Интерфейс в Go — это абстрактный тип, который определяет набор методов.  
> Тип считается реализующим интерфейс, если он реализует все методы, указанные в интерфейсе.

#### 3. Чем отличаются RWMutex от Mutex?
> Mutex только одна горутина может достучатся до процесса
RWMutex позволяет читать нескольким горутинам, но блокирует все,
когда кто то пытается записать

> RWMutex применяется со структурами, безопасными для параллельного чтения, но небезопасными для записи. RWMutex позволяет не блокировать чтение, если в данный момент не идёт запись.

#### 4. Чем отличаются буферизированные и не буферизированные каналы?  
> При отправке сообщения в небуферизированный канал поток блокируется и ждёт, когда кто-то извлечёт сообщение.  
> В буферизированном канале поток блокируется когда буфер заполнен полностью  

#### 5. Какой размер у структуры struct{}{}?  
> 0 

#### 6. Есть ли в Go перегрузка методов или операторов?  
> В Go нельзя определить несколько методов с одинаковым именем, но разными сигнатурами, и нельзя перегружать операторы  

#### 7. В какой последовательности будут выведены элементы map[int]int?  
Пример:
m[0]=1
m[1]=124
m[2]=281

> Порядок не гарантируется

#### 8. В чем разница make и new?  
>make используется для инициализации встроенных ссылочных типов данных: слайсов (slice), мап (map) и каналов (chan).
>make возвращает инициализированный объект

>new используется для выделения памяти под любой тип данных (включая пользовательские типы).  
>new возвращает указатель на выделенную память.

#### 9. Сколько существует способов задать переменную типа slice или map?
> var slice []int
> slice := []int{}
> slice := make([]int)
> slice := make([]int,5)
> slice := make([]int,5,5)
> slice:= *new([]int)

> var m map[int]int
> m := map[string]int{}
> m := make(map[int]int)
> m := *new(map[int]int)

#### 10. Что выведет данная программа и почему?

>func update(p *int) { //передается копия указателя p, а не сам указатель  
>b := 2  
>p = &b  
>}  
>  
>func main() {  
>var (  
>a = 1  
>p = &a  
>)  
>fmt.Println(*p) //1  
>update(p)  
>fmt.Println(*p) //1  
>}  

> в функции update мы работаем с копией  
> => меняется не значение по указателю, а значение самого указателя, которое остаётся в локальной видимости  

#### 11. Что выведет данная программа и почему?  

>func main() {  
>wg := sync.WaitGroup{}  
>for i := 0; i < 5; i++ {  
>wg.Add(1)  
>go func(wg sync.WaitGroup, i int) {  
>fmt.Println(i)  
>wg.Done()  
>}(wg, i)  
>}  
>wg.Wait()  
>fmt.Println("exit")  
>}  

> рандом значений 0-5 и deadlock, т.к. в o func(wg sync.WaitGroup, i int)  
> передается WaitGroup, а не указатель на него

>func main() {  
>wg := sync.WaitGroup{}  
>for i := 0; i < 5; i++ {  
>wg.Add(1)  
>go func(wg *sync.WaitGroup, i int) {  
>fmt.Println(i)  
>wg.Done()  
>}(&wg, i)  
>}  
>wg.Wait()  
>fmt.Println("exit")  
>}  

#### 12. Что выведет данная программа и почему?

>func main() {
>n := 0
>if true {
>n := 1
>n++
>}
>fmt.Println(n) //0
>}

>т.к в теле if созадется новая переменная n и изменяется ее значение,а изначально заданная остается 0  

#### 13. Что выведет данная программа и почему?

>func someAction(v []int8, b int8) {  
>v[0] = 100 // [100 2 3 4 5]  
>v = append(v, b) // [100 2 3 4 5 6] создает новый массив, т.к. выходит за пределы емкости начального  
>}  
>
>func main() {  
>var a = []int8{1, 2, 3, 4, 5}  
>someAction(a, 6)  
>fmt.Println(a) //// [100 2 3 4 5]  
>}  


#### 14. Что выведет данная программа и почему?

>func main() {  
>slice := []string{"a", "a"} //len 2, cap 2 -> m1  
>
>	func(slice []string) { //копия  
>		slice = append(slice, "a") //{"a", "a", "a"} len 3, cap 4 -> m2  
>		slice[0] = "b"             //{"b", "a", "a"} len 3, cap 4 -> m2  
>		slice[1] = "b"             //{"b", "b", "a"} len 3, cap 4 -> m2  
>		fmt.Print(slice)           //{"b", "b", "a"} len 3, cap 4 -> m2  
>	}(slice)  
>
>	fmt.Print(slice) //{"a", "a"}  
>}




